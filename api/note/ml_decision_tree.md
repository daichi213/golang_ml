# DecisionTree内部設計

- 引数の読み込み

- データセットの読み込み

- ForLoop(葉ノードの生成)
	- ループ回数カウント変数を定義する
	```go
	depth:=0
	```
	- ランダムで特徴量を選択する

	- 選択した特徴量の中の最小値と最大値を取得する
	min , max

	- 取得した最小値と最大値の範囲からランダムで値を選択し、その値を閾値とする

	```go
	// max, minはfloat型とする（出ないとFloor関数でエラーになる）
	intercept := math.rand.Float64()
	// if max - min>1
	threshold := math.Floor(max - min) + min + intercept
	```

	- 葉ノードを定義する
	```go
	node := [][] *CaliforniaHousingData{}
	```

	- ForLoop(データの分割)
		- 決定した閾値を元にして、データセットを分割し、配列へ格納する
		```go
		// 次の階層のノード数はdepth*2
		// ノードにデータが分類されていない場合はスキップするように処理を実装する
		for j := 0; j<len(data); j++ {
			if 
			node[i][]
		}
		```
- ループ回数カウント変数に+1する


		node[深さ][その深さの番号]

						node[0][0]
							|
		node[1][0] - 		-		- node[1][1]
			|							|
node[2][0] - - node[2][1]	node[2][2] - - node[2][3]

子ノードの生成は以下で行う
node[i+1][k*2+1], node[i+1][k*2+2]

親ノードへのアクセスは以下で行う
node[i-1][k//2]



コストの計算（ジニ係数・エントロピーのどちらかは関数の引数から制御する）

<!-- TODO vscode拡張機能の一括インストールについてメモ・記事？を書く -->

<!-- TODO データにスポットをあてたフローチャートを作成する -->

## データセット分類の流れ（整理用）

- i = 0の時
	- node[0][0]から分岐
		- node[0][0]（root nodeを生成）
		- node[0][0]の下にchild nodeを生成
		- node[1][0]で閾値を元にデータセットの分類を行う
		- node[1][1]ではnode[1][0]で分類されなかったデータセットを割り当てる
- i = 1の時
	- node[1][0]から分岐
		- node[1][0]の下にchild nodeを生成（node[2][0], node[2][1]）
		- node[2][0]で閾値を元にデータセットの分類を行う
		- node[2][1]ではnode[2][0]で分類されなかったデータセットを割り当てる
	- node[1][1]から分岐
		- node[1][1]の下にchild nodeを生成（node[2][2], node[2][3]）
		- node[2][2]で閾値を元にデータセットの分類を行う
		- node[2][3]ではnode[2][2]で分類されなかったデータセットを割り当てる
	2^n